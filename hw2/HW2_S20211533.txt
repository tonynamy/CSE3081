1.
양수 인덱스를 가지는 X와 Y가 있을 때
1 <= i <= m, 1 <= j <= n 에 대해
dp[i][j]을 X의 i번째 원소와 Y의 j번째 원소가 만날 때의 유사도 최댓값으로 정의하면,

dp[i][j] = max { dp[i-1][j-1] + X의 i번째 원소와 Y의 j번째 원소의 유사도(s 혹은 -f), dp[i-1][j] - p, dp[i][j-1] - p } 로 정의할 수 있다.
각각의 케이스는 앞에서부터 X의 i번째 원소와 Y의 j번째 원소가 정상적으로 만난 경우, X의 i번째 원소와 Y의 indel이 만난 경우, X의 indel과 Y의 j번째 원소가 만난 경우이다.

위 점화식을 해결하면 문제를 해결할 수 있다.

2.
양수 인덱스를 가지는 문자열 S의 길이를 l이라고 하면
1 <= i, j <= l 에 대해
dp[i][j]를 문자열의 i~j 구간에 존재하는 회문 개수의 최솟값으로 정의하면

(i = j인 경우는 1)
dp[i][j]는 S[i]==S[j] 이고 j-i > 1 이며 dp[i+1][j-1]==1 이라면 1이고(팰린드롬인 경우)
그렇지 않다면 dp[i][j]는 i <= k < j 인 k에 대해 dp[i][k] + dp[k+1][j]의 최솟값이다(분할 정복)
위 점화식을 해결하면 문제를 해결할 수 있다.

3.
양수 인덱스를 가지는 l개의 왼손 카드 뭉치 L, r개의 오른손 카드 뭉치 R, 최종 카드뭉치 P가 있다고 하면
1 <= i <= l, 1 <= j <= r에 대해
dp[i][j]를 L에서 첫번째부터 i개의 카드를 꺼내고 R에서 j개의 카드를 꺼냈을 때 P[1:i+j] 뭉치를 만들 수 있는지 여부로 정의하면,

dp[i][j] = (dp[i-1][j] 이고 L[i] == P[i+j]) 또는 (dp[i][j-1] 이고 R[j] == P[i+j]) 로 정의할 수 있다.

위 점화식을 해결하면 문제를 해결할 수 있다.